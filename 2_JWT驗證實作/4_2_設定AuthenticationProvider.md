# 實作AuthenticationProvider
這個類別主要是負責檢查使用者是否存在於資料庫中，若沒有則拋出錯誤，正確的話則回傳新的TokenAuthentication，這裡是簡單的驗證流程，可以依照需求更改邏輯。

```java
@Component
public class TokenAuthenticationProvider implements AuthenticationProvider {
		
	private Logger LOG = Logger.getLogger(TokenAuthenticationProvider.class.getName());
	
	/**
	 * 使用者帳號資料庫
	 */
	@Autowired
	private UserInfoRepository userInfoRepository;
	
	@Autowired
	private RoleRepository roleRepository;

	/**
	 * 由ProcessinngFilter呼叫Manager將客製化的Authentication物件傳進來
	 */
	@Override
	public Authentication authenticate(Authentication authentication) throws AuthenticationException {
		LOG.info("TokenAuthenticationProvider authenticate......");
		// extracting credentials from user.	
		String name = authentication.getName();
		String password =  (String) ((TokenAuthentication)authentication).getCredentials();
		authentication.getAuthorities();
		
		
		// checking if the user is available. In general, checking if the user is exist in the repository.
		UserInfoEntity userInfoEntity = userInfoRepository.getUserByName(name);
		
		// 1.0 when the user is invalid, throwing an exception.
		if(userInfoEntity == null) {
			throw new UsernameNotFoundException("the user is invalid");
		}
		
		List<RoleEntity> roleEntity = roleRepository.getRoleByName(name);
		
		
		
		// 2.0 when the user is valid
		// 2_1 creating a new Authentication object
		// 2_2 setting a token which is generated by jwtService and Authentication object.		 
		return new TokenAuthentication(name,password,roleEntity);
//		return  authentication;
	}

	/**
	 * The “supports” method tells Spring’s AuthenticationManager what class of input Authentication this provider is capable of processing.
	 */
	@Override
	public boolean supports(Class<?> authentication) {
		
		return authentication.equals(TokenAuthentication.class);
	}

}

```

* authenticate
由AuthenticationProcessingFilter呼叫authenticate方法並傳入帶有使用者帳號密碼的Authentication。

* supports 
設定在甚麼樣的情況下ProviderMannager會使用這個自訂義的provider驗證，這裡是當authentication是TokenAuthentication的實體物件時就適用。